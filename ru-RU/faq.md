---
layout: ru-RU/faq
title: Часто задаваемые вовпросы (Frequently Asked Questions) &middot; по языку программирования Rust
---

# Часто Задаваемые Вопросы

<p class="faq-intro">
Эта страница создана, для того чтобы отвечать на общие вопросы о языке программирования Rust. Это не полное руководство к языку и это не учебное руководство. Здесть опубликованы ответы на неоднократно задаваемых вопросы, которые обсуждались на встрече сообщества Rust, а также разъяснение причин некоторых дизайнерских решений языка Rust.
</p>

<p class="faq-intro">
Если у вас есть какой-то общий или важный вопрос, который, не оставлен без ответа - не стесняйтесь, пишите его и <a href="https://github.com/rust-lang/rust-www/blob/master/CONTRIBUTING.md">мы его осветим</a>.</p>

<div id="toc">
    <h2>Содержание</h2><a href="#toggle-toc"></a>
    <div class="contents">
        <ol id="toc-contents">
            <li> <a href="#project"> Проект Rust </a> </ li>
            <li> <a href="#performance"> Производительность </a> </ li>
            <li> <a href="#syntax"> Синтаксис </a> </ li>
            <li> <a href="#numerics"> Числа </a> </ li>
            <li> <a href="#strings"> Строки </a> </ li>
            <li> <a href="#collections"> Коллекции </a> </ li>
            <li> <a href="#ownership"> Владение </a> </ li>
            <li> <a href="#lifetimes"> Время жизни </a> </ li>
            <li> <a href="#generics"> Общие характеристики </a> </ li>
            <li> <a href="#input-output"> Ввод / вывод </a> </ li>
            <li> <a href="#error-handling"> Обработка ошибок </a> </ li>
            <li> <a href="#concurrency"> Параллельность </a> </ li>
            <li> <a href="#macros"> Макросы </a> </ li>
            <li> <a href="#debugging"> Отладка и инструменты </a> </ li>
            <li> <a href="#low-level"> Низкоуровневое программирование  </a> </ li>
            <li> <a href="#cross-platform"> Кросс-платформенность </a> </ li>
            <li> <a href="#modules-and-crates"> Модули и контейнеры </a> </ li>
            <li> <a href="#libraries"> Библиотеки </a> </ li>
            <li> <a href="#design-patterns"> Шаблоны проектирования </a> </ li>
            <li> <a href="#other-languages"> Другие языки </a> </ li>
            <li> <a href="#documentation"> Документация </a> </ li>
        </ol>
    </div>
</div>

<h2 id="project">Проект Rust</h2>

<h3><a href="#what-is-this-projects-goal" name="what-is-this-projects-goal">
Какова цель этого проекта?
</a></h3>

Разработать и внедрить безопасный, параллельный, практичный системный язык.

Rust существует, так как другие языки на этом уровне абстракции и эффективности неудовлетворительны. В частности:

1. Слишком мало внимания уделяется безопасности.
2. Низкая поддержка параллелизма.
3. Отсутствие практических преимуществ.
4. Предлагается ограниченный контроль над ресурсами.

Rust существует как альтернатива, которая обеспечивает как эффективный код, так и комфортный уровень абстракции, при этом улучшается во всех этих направлениях.

<h3><a href="#is-this-project-controlled-by-mozilla" name="is-this-project-controlled-by-mozilla">
Этот проект контролируется Mozilla?
</a></h3>

Нет. В 2006 году Rust был создан Грэйдоном Хором (Graydon Hoare) и развивался им в свободное время и оставался таким более 3 лет. Mozilla приняла участие в его развитии в 2009 году, когда язык был достаточно зрелым, чтобы выполнять базовые тесты и демонстрировать свои основные концепции. Хотя он по-прежнему спонсируется Mozilla, Rust разрабатывается разнообразным сообществом энтузиастов из разных уголков мира. Команда [Rust Team](https://www.rust-lang.org/team.html) состоит из членов Mozilla и не Mozilla, а «rust» на GitHub имеет более [1,900 уникальных контрибьюторов](https://github.com/rust-lang/rust/).

Что касается [управления проектами](https://github.com/rust-lang/rfcs/blob/master/text/1068-rust-governance.md), то Rust управляется основной командой, которая устанавливает видение и приоритеты для проекта, направляя его с глобальной точки зрения. Также есть подгруппы для руководства и развития определенных областей, включая основной язык, компилятор, библиотеки Rust, инструменты Rust и официальных сообществ Rust. Проекты в каждой из этих областей продвигаются через [RFC-процесс](https://github.com/rust-lang/rfcs). Для изменений, которые не требуют RFC, решения принимаются посредством запросов на загрузку в репозитории [`rustc`](https://github.com/rust-lang/rust).

<h3><a href="#what-are-some-non-goals" name="what-are-some-non-goals">
Какие цели не преследует проект Rust?
</a></h3>

1. Мы не используем самые последние передовых технологий. Мы считаем, что старые, провенные иструменты и методы лучше.
2. Мы не гонимся за выразительностью, минимализмом или элегантностью. Это желательные, но второстепенные цели.
3. Мы не собираемся реализовывать полный набор функций C++ или любого другого языка. Язык Rust должен обеспечивать основной функционал.
4. Мы не намерены быть 100% статическими, 100% безопасными, 100% отражающими или слишком догматическими в любом другом смысле. Существуют компромиссы.
5. Мы не требуем, чтобы Rust работал на «любой возможной платформе». В конечном итоге он должен работать без ненужных компромиссов на широко используемых аппаратных и программных платформах.

<h3><a href="#how-does-mozilla-use-rust" name="how-does-mozilla-use-rust">
В каких проектах Mozilla использует Rust?
</a></h3>

Основной проект - [Servo](https://github.com/servo/servo), экспериментальный движок браузера Mozilla. Также ведётся работа над [интеграцией компонентов Rust](https://bugzilla.mozilla.org/show_bug.cgi?id=1135640) в Firefox.

<h3><a href="#what-examples-are-there-of-large-rust-projects" name="what-examples-are-there-of-large-rust-projects">
Есть ли примеры крупных проектов Rust?
</a></h3>

В настоящее время существуют дву крупных проекта на Rust с открытым исходным кодом. Это  [Servo](https://github.com/servo/servo) и компилятор [Rust compiler](https://github.com/rust-lang/rust).

<h3><a href="#who-else-is-using-rust" name="who-else-is-using-rust">
Кто уже использует Rust?
</a></h3>

[Растущее число организаций!](Friends.html)

<h3><a href="#how-can-i-try-rust-easily" name="how-can-i-try-rust-easily">
Могу попробовать начать программировать на Rust где-либо?
</a></h3>

Самый простой способ попробовать Rust в работе - с помощью [playpen](https://play.rust-lang.org/), онлайн-приложение для написания и запуска кода Rust. Если вы хотите попробовать Rust на вашей системе, [установить его](https://www.rust-lang.org/install.html) и пройдите через [Guessing Game](https://doc.rust-lang.org/stable/book/second-edition/ch02-00-guessing-game-tutorial.html) учебник в книге.

<h3><a href="#how-do-i-get-help-with-rust-issues" name="how-do-i-get-help-with-rust-issues">
Как я могу получить помощь в вопросах по Rust?
</a></h3>

Есть несколько способов:

- Сообщение в [users.rust-lang.org](https://users.rust-lang.org/), официальный форум пользователей Rust
- Спросите в официальном канале [Rust IRC](https://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust) (#rust на irc.mozilla.org)
- Попросите [Stackoverflow](https://stackoverflow.com/questions/tagged/rust) с тегом «rust»
- Опубликовать в [/r/rust](https://www.reddit.com/r/rust), неофициальный канал Rust

<h3><a href="#why-has-rust-changed-so-much" name="why-has-rust-changed-so-much">
Почему Rust сильно изменилась с течением времени?
</a></h3>

Rust начал разрабатываться, как безопасноый, но удобный в использовании системный язык программирования. Стремясь к этой цели, было исследованно множество идей, некоторые из которых были сохранееы (время жизни, трейты), в то время как другие были отброшены. Кроме того, в начале до версии 1.0 большая часть стандартной библиотеки была переписана, поскольку ранние проекты были обновлены, чтобы наилучшим образом использовать функции Rust и обеспечивать качественные, совместимые межплатформенные API. Теперь, когда Rust достиг 1.0, язык гарантированно будет «стабильным»; и в то время как он может продолжать развиваться. Код, который работает на текущей версии Rust, должен продолжать работать (компилироваться) и с использованием функционал будущих версий.

<h3><a href="#how-does-rust-language-versioning-work" name="how-does-rust-language-versioning-work">
Как работает управление версиями Rust?
</a></h3>

Языковое исполнение Rust следует [SemVer](http://semver.org/). Обратно несовместимыми изменения стабильных API-интерфейсов допускаются только в младших версиях, если эти изменения исправляют ошибки компилятора, исправляют ошибки безопасности. Более подробные рекомендации по незначительным изменениям в версии доступны в качестве утвержденных RFC как для [языка](https://github.com/rust-lang/rfcs/blob/master/text/1122-language-semver.md), так и [стандартной библиотеки](https://github.com/rust-lang/rfcs/blob/master/text/1105-api-evolution.md).

Rust поддерживает три «канала релиза»: стабильный, бета-и ночной. Стабильные и бета-версии обновляются каждые шесть недель, причем текущая ночная становится новой бета-версией, а текущая бета-версия становится новой стабильной. Языковые и стандартные функции библиотеки, помеченные как неустойчивые или скрытые функции, могут использоваться только в ночном версии. Новые возможности утверждаются основной группой и соответствующими подгруппами. Такой подход позволяет проводить эксперименты, обеспечивая при этом надежные гарантии обратной совместимости.

Дополнительные сведения читайте в блоге Rust [«Стабильность, как конечный результат».](Http://blog.rust-lang.org/2014/10/30/Stability.html)

<h3><a href="#can-i-use-unstable-features-on-the-beta-or-stable-channel" name="can-i-use-unstable-features-on-the-beta-or-stable-channel">
Могу ли я использовать нестабильные функции в бета-версии или стабильный версии?
</a></h3>

Нет, нельзя. Разработчики усердно работают, чтобы обеспечить прочные гарантии стабильности функций, предусмотренных на бета и в стабильной версии. Когда что-то нестабильно, это означает, что мы пока не можем предоставить эти гарантии, и не хотим, чтобы люди, полагающиеся на него, были уверены в стабильной работе. Это дает нам возможность попробовать изменения в дикой природе на ночном канале выпуска, сохраняя при этом надежные гарантии для людей, стремящихся к стабильности.

Вещи стабилизируются все время, а бета-версии и стабильные каналы обновляются каждые шесть недель, причем иногда исправления принимаются в бета-версии в другое время. Если вы ожидаете, что функция будет доступна без использования ночного канала выпуска, вы можете найти ее проблему отслеживания, проверив [`B-unstable`](https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+tracking+label%3AB-unstable) тег на трекер проблемы.

<h3><a href="#what-are-feature-gates" name="what-are-feature-gates">
Что такое «Feature Gates»?
</a></h3>

«Feature Gates» - это механизм, который Rust использует для стабилизации функций компилятора, языка и стандартной библиотеки. Функция «gated» доступна только на ночном канале, а затем только тогда, когда она явно разрешена с помощью атрибутов `#[feature]` или аргумента командной строки `-Z unstable-options`. Когда функция стабилизируется, она становится доступной на стабильном канале релиза и не нуждается в явной активации. В этот момент признак считается «нелогичным». Функциональные ворота позволяют разработчикам тестировать экспериментальные функции, пока они находятся в разработке, прежде чем они будут доступны на устойчивом языке.

<h3><a href="#why-a-dual-mit-asl2-license" name="why-a-dual-mit-asl2-license">
Почему используется двойная лицензия MIT / ASL2?
</a></h3>

Лицензия Apache включает важную защиту от патентной агрессии, но она несовместима с GPL, версия 2. Чтобы избежать проблем с использованием Rust с GPL2, она лицензируется MIT.

<h3><a href="#why-a-permissive-license" name="why-a-permissive-license">
Почему разрешающая лицензия в стиле BSD, а не MPL?
</a></h3>

Отчасти это связано с предпочтением оригинального разработчика (Graydon) и отчасти из-за того, что языки имеют более широкую аудиторию и более разнообразный набор возможных вложений и конечных целей, чем такие продукты, как веб-браузеры. Мы хотели бы как можно скорее обратиться к таким потенциальным контрибьютерам.

<h2 id="performance">Производительность</h2>

<h3><a href="#how-fast-is-rust" name="how-fast-is-rust">
Насколько язык Rust быстр?
</a></h3>

Он быстр! Rust уже конкурирует с идиоматическими C и C ++ в ряде эталонных тестов (например, [Benchmarks Game](https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/rust.html) и [другие](https://github.com/kostya/benchmarks)).

Подобно C++, Rust занимает [нулевые затраты абстракции](http://blog.rust-lang.org/2015/05/11/traits.html) в качестве одного из своих основных принципов: ни одна абстракция Rust не налагает глобального штрафа за производительность, и нет накладных расходов от любой системы времени исполнения в традиционном смысле.

Учитывая, что Rust построен на LLVM и стремится походить на Clang с точки зрения LLVM, любые улучшения производительности LLVM также помогают Rust. В конечном счете, более богатая информация в системе типа Rust также должна включать оптимизацию, которая является сложной или невозможной для кода C/C++.

<h3><a href="#is-rust-garbage-collected" name="is-rust-garbage-collected">
В Rust используется куча?
</a></h3>

Нет. Одним из ключевых новшеств Rust является гарантия безопасности памяти *(без segfaults)* без необходимости сбора мусора.

Предотвращая GC, Rust может предложить множество преимуществ: предсказуемую очистку ресурсов, снижение накладных расходов для управления памятью и, по существу, отсутствие системы времени исполнения. Все эти черты делают Rust четким и легким встраиванием в произвольные контексты и упрощают [интегрировать код Rust с языками, имеющими GC](http://calculist.org/blog/2015/12/23/neon-node-rust/).

Rust избегает необходимости в GC через свою систему владения и заимствования, но эта же система помогает с множеством других проблем, в том числе
[управление ресурсами в целом](http://blog.skylight.io/rust-means-never-having-to-close-a-socket/) и [параллелизм](http://blog.rust-lang.org /2015/04/10/Fearless-Concurrency.html).

В случае, когда единичного владения недостаточно, программы Rust полагаются на стандартный тип интеллектуального указателя с подсчетом ссылок, [`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html), и его многопоточный аналог [`Arc`](https://doc.rust-lang.org/std/sync/struct.Arc.html) вместо GC.

Тем не менее мы рассматриваем *необязательный сбор мусора* в качестве будущего расширение. Целью является обеспечение плавной интеграции с
собранные с мусором периоды времени, например, предлагаемые
[SpiderMonkey](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey)
и [V8](https://developers.google.com/v8/?hl=ru) движки JavaScript.
Наконец, некоторые исследователи
[сборщики мусора Rust](https://manishearth.github.io/blog/2015/09/01/designing-a-gc-in-rust/)
без поддержки компилятора.
<h3><a href="#why-is-my-program-slow" name="why-is-my-program-slow">
Почему программа может работать медленно?
</a></h3>

По умолчанию компилятор [не производит оптимизацию кода](https://users.rust-lang.org/t/why-does-cargo-build-not-optimise-by-default/4150/3).

Для оптимизации кода компилируете `cargo`, используя флаг `--release`. Если вы скомпилируете `rustc` напрямую, используйте флаг` -O`. Любой из них включит оптимизацию.

<h3><a href="#why-is-rustc-slow" name="why-is-rustc-slow">
Компиляция кода Rust происхожит медленно. Возможные причины?
</a></h3>

Перевод и оптимизация кода. Rust обеспечивает абстракции высокого уровня, которые скомпилируются в эффективный машинный код, и эти переводы требуют времени для запуска, особенно при оптимизации.

Из-за большого количесва файлов исходного кода компиляция моет происходит медленно. Над этой проблемой сейчас ведётся работа. Решение [умная компиляция](https://github.com/rust-lang/rfcs/blob/master/text/1298-incremental-compilation.md), которая должна превзойти модель компиляции в C++.

Помимо модели компиляции, есть несколько других аспектов разработки языка Rust и реализации компилятора, которые влияют на производительность во время компиляции.

Во-первых, Rust имеет систему с умеренно сложным типом и должен потратить нематерифицированное количество времени компиляции, применяя ограничения, которые делают Rust безопасным во время выполнения.

Во-вторых, компилятор Rust страдает от долговременной технической задолженности и, в частности, генерирует некачественный LLVM IR, который LLVM должен тратить время на «фиксацию». Добавление нового внутреннего представления под названием [MIR](https://github.com/rust-lang/rfcs/blob/master/text/1211-mir.md) в компилятор Rust дает возможность выполнять больше оптимизаций и улучшить качество генерируемого LLVM IR, но эта работа еще не состоялась.

В-третьих, использование Rust LLVM для генерации кода - это обоюдоострый меч: хотя он позволяет Rust иметь производительность во время мирового класса, LLVM - это большая структура, которая не ориентирована на производительность во время компиляции, особенно при работе с некачественными входы.

Наконец, в то время как предпочтительная стратегия Rust для мономорфизации генериков (как в C++) создает быстрый код, она требует создания гораздобольшего кода, чем другие стратегии перевода. Программисты Rust могут использовать объекты признаков, чтобы отменить этот раздутый код, используя динамическую диспетчеризацию.

<h3><a href="#why-are-rusts-hashmaps-slow" name="why-are-rusts-hashmaps-slow">
Почему в Rust медленный <code>HashMap</code>?
</a></h3>

П умолчанию [`HashMap`][HashMap] использует алгоритм [SipHash](https://131002.net/siphash/), который реализован так чтобы предотвращать [коллизии](http://programmingisterrible.com/post/40620375793/hash-table-denial-of-service-attacks-revisited) предоставляя [возможную производительность](https://www.reddit.com/r/rust/comments/3hw9zf/rust_hasher_comparisons/cub4oh6).

Хотя SipHash [демонстрирует конкурентоспособность](http://cglab.ca/%7Eabeinges/blah/hash-rs/) во многих случаях, в одном случае, когда он заметно медленнее, чем другие алгоритмы хэширования, это короткие ключи, такие как целые числа. Вот почему программисты Rust часто наблюдают медленную работу с [`HashMap`] [HashMap]. В этих случаях часто рекомендуется использовать хешер [FNV](https://crates.io/crates/fnv), но имейте в виду, что он не обладает теми же свойствами сопротивления столкновению, что и SipHash.

<h3><a href="#why-is-there-no-integrated-benchmarking" name="why-is-there-no-integrated-benchmarking">
Почему нет интегрированной инфраструктуры бенчмаркинга?
</a></h3>

Существует, но он доступен только на ночном канале релиза. В конечном итоге мы планируем создать подключаемую систему для интегрированных контрольных показателей, но в то же время существующая система [считается нестабильной](https://github.com/rust-lang/rust/issues/29553).

<h3><a href="#does-rust-do-tail-call-optimization" name="does-rust-do-tail-call-optimization">
Производится ли в Rust оптимизация вызовов?
</a></h3>

Обычно нет. Оптимизация вызовов может быть реализована только в [ограниченных случаях](http://llvm.org/docs/CodeGenerator.html#sibling-call-optimization) и [не гарантируется](https://mail.mozilla.org/pipermail/rust-dev/2013-April/003557.html). Т.к эта опция хотелась сообществом, язык Rust имеет зарезервированное ключевое слово (`become`). 

<h3><a href="#does-rust-have-a-runtime" name="does-rust-have-a-runtime">
Имеет ли Rust runtime?
</a></h3>

Не в типичном смысле, используемом такими языками, как Java, но части стандартной библиотеки Rust можно считать «средой выполнения», предоставляющей кучи, обратные трассировки, разматывание и защиту стека. Существует [небольшое количество кода инициализации](https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src/libstd/rt.rs#L43), который выполняется до функции пользователя `main`. Стандартная библиотека Rustre также ссылается на стандартную библиотеку C, которая делает аналогичную [инициализацию времени выполнения](http://www.embecosm.com/appnotes/ean9/html/ch05s02.html). Код Rust может быть скомпилирован без стандартной библиотеки, и в этом случае время выполнения примерно эквивалентно C.
